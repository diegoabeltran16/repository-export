{
  "title": "-internal_importer_reader_test.go",
  "text": "## [[Tags]]\n[[--- üß¨ Por Clasificar]]\n\n```go\n// reader_test.go ‚Äì Tests unitarios para ReadTiddlers en reader.go\n// --------------------------------------------------------------------------------\n// Contexto pedag√≥gico\n// -------------------\n// Este archivo acompa√±a a *reader.go* y demuestra, mediante **pruebas unitarias**\n// escritas con el paquete `testing` est√°ndar de Go, que la funci√≥n `ReadTiddlers`\n// interpreta correctamente los dos formatos de exportaci√≥n que genera\n// TiddlyWiki.\n//\n// Cada prueba sigue la estructura *Arrange ‚Üí Act ‚Üí Assert* aunque, para mantener\n// la convenci√≥n idiom√°tica de Go, las secciones no se etiquetan expl√≠citamente.\n//\n// --------------------------------------------------------------------------------\n\npackage importer\n\nimport (\n\t\"context\"\n\t\"os\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/diegoabeltran16/OpenPages-Source/models\"\n)\n\n// writeTempFile crea un archivo temporal con el contenido recibido y devuelve\n// su ruta.  Cualquier fallo interrumpe la prueba.\nfunc writeTempFile(t *testing.T, content string) string {\n\tt.Helper()\n\tf, err := os.CreateTemp(\"\", \"tiddlers-*.json\")\n\tif err != nil {\n\t\tt.Fatalf(\"error creando archivo temporal: %v\", err)\n\t}\n\tdefer f.Close()\n\n\tif _, err := f.WriteString(content); err != nil {\n\t\tt.Fatalf(\"error escribiendo archivo temporal: %v\", err)\n\t}\n\treturn f.Name()\n}\n\n// TestRead_Array verifica la ruta feliz cuando el JSON es un array.\nfunc TestRead_Array(t *testing.T) {\n\t// Arrange\n\tjsonData := `[\n      {\"title\":\"Foo\",\"text\":\"txt\",\"type\":\"text/plain\",\"tags\":\"[[a]]\",\"created\":\"20250101\",\"modified\":\"20250102\"}\n    ]`\n\tpath := writeTempFile(t, jsonData)\n\tdefer os.Remove(path)\n\n\twant := []models.Tiddler{{\n\t\tTitle:    \"Foo\",\n\t\tText:     \"txt\",\n\t\tType:     \"text/plain\",\n\t\tTags:     \"[[a]]\",\n\t\tCreated:  \"20250101\",\n\t\tModified: \"20250102\",\n\t}}\n\n\t// Act\n\tgot, err := Read(context.Background(), path)\n\tif err != nil {\n\t\tt.Fatalf(\"Read(array) devolvi√≥ error: %v\", err)\n\t}\n\n\t// Assert\n\tif !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"Read(array) = %+v, want %+v\", got, want)\n\t}\n}\n\n// TestRead_Map verifica el parseo cuando el JSON es un objeto plano.\nfunc TestRead_Map(t *testing.T) {\n\tjsonData := `{\"Bar\":{\"title\":\"Bar\",\"text\":\"x\",\"type\":\"application/json\",\"tags\":\"[[x]]\",\"created\":\"20250401\",\"modified\":\"20250402\"}}`\n\tpath := writeTempFile(t, jsonData)\n\tdefer os.Remove(path)\n\n\twant := []models.Tiddler{{\n\t\tTitle:    \"Bar\",\n\t\tText:     \"x\",\n\t\tType:     \"application/json\",\n\t\tTags:     \"[[x]]\",\n\t\tCreated:  \"20250401\",\n\t\tModified: \"20250402\",\n\t}}\n\n\tgot, err := Read(context.Background(), path)\n\tif err != nil {\n\t\tt.Fatalf(\"Read(map) devolvi√≥ error: %v\", err)\n\t}\n\tif !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"Read(map) = %+v, want %+v\", got, want)\n\t}\n}\n\n```",
  "tags": "[[--- üß¨ Por Clasificar]]",
  "type": "text/markdown",
  "created": "20250531224148701",
  "modified": "20250531224148701"
}