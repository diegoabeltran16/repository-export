{
  "title": "-rep-export-Windows_tiddler_exporter.py",
  "text": "## [[Tags]]\n[[--- üß¨ Por Clasificar]]\n\n```python\n\"\"\"\nüì¶ Script: tiddler_exporter.py\nüìç Ubicaci√≥n: scripts/tiddler_exporter.py\n\nüß† Funci√≥n:\nEste script recorre todos los archivos fuente del proyecto, detecta si su contenido ha cambiado,\ny si es as√≠, genera un archivo `.json` en formato TiddlyWiki listo para ser importado.\n\nüîñ Cada archivo se convierte en un \"tiddler\", con:\n  - Nombre prefijado con `-` (ej: -src_logger.py)\n  - Tags sem√°nticos desde `OpenPages.json` v√≠a `tag_mapper.py`\n  - Bloque markdown con c√≥digo resaltado seg√∫n lenguaje\n\nüéØ Compatible con TiddlyWiki, offline, AI-ready y 100% Python puro.\n\n‚úÖ C√≥mo ejecutarlo:\n\n    # Exporta solo si hay cambios\n    python scripts/tiddler_exporter.py\n\n    # Modo simulaci√≥n (muestra qu√© archivos cambiar√≠an)\n    python scripts/tiddler_exporter.py --dry-run\n\"\"\"\n\nimport os\nimport json\nimport hashlib\nimport tag_mapper\nfrom datetime import datetime, timezone\nfrom pathlib import Path\nfrom typing import List\n\n# ==========================\n# ‚öôÔ∏è CONFIGURACI√ìN GENERAL\n# ==========================\n\nROOT_DIR = Path(__file__).resolve().parents[1]  # ra√≠z del repo\nSCRIPT_DIR = Path(__file__).parent\nOUTPUT_DIR = SCRIPT_DIR / \"tiddlers-export\"\nHASH_FILE = SCRIPT_DIR / \".hashes.json\"\n\nVALID_EXTENSIONS = ['.py', '.md', '.json', '.sh', '.html', '.css', '.yml', '.txt']\nALLOWED_FILENAMES = ['.gitignore']  # Archivos sin extensi√≥n pero importantes\n\nIGNORE_DIRS = [\n    '__pycache__', 'venv', '.venv', 'dist', 'node_modules', 'output', 'input',\n    '.pytest_cache', 'configs', 'media', 'project_details', 'tiddlers-export'\n]\n\nLANGUAGE_MAP = {\n    '.py': 'python',\n    '.md': 'markdown',\n    '.json': 'json',\n    '.sh': 'bash',\n    '.yml': 'bash',\n    '.html': 'html',\n    '.txt': 'txt',\n    '.css': 'css'\n}\n\nSPECIAL_LANGUAGES = {\n    '.gitignore': 'gitignore'\n}\n\n# ==============================\n# üîé FUNCIONES AUXILIARES\n# ==============================\n\ndef get_all_files(directory: Path) -> List[Path]:\n    \"\"\"Recorre el proyecto y devuelve archivos v√°lidos para exportar.\"\"\"\n    all_files = []\n    for root, dirs, files in os.walk(directory):\n        dirs[:] = [d for d in dirs if d not in IGNORE_DIRS]\n        for file in files:\n            ext = Path(file).suffix\n            if ext in VALID_EXTENSIONS or file in ALLOWED_FILENAMES:\n                all_files.append(Path(root) / file)\n    return all_files\n\ndef get_hash(content: str) -> str:\n    \"\"\"Genera hash SHA-1 para detectar cambios en el archivo.\"\"\"\n    return hashlib.sha1(content.encode('utf-8')).hexdigest()\n\ndef safe_title(path: Path) -> str:\n    \"\"\"Convierte una ruta en t√≠tulo de tiddler v√°lido, prefijado con '-'.\"\"\"\n    return '-' + str(path.relative_to(ROOT_DIR)).replace(os.sep, '_')\n\ndef detect_language(file_path: Path) -> str:\n    \"\"\"Detecta el lenguaje para resaltar el bloque de c√≥digo en markdown.\"\"\"\n    if file_path.name in SPECIAL_LANGUAGES:\n        return SPECIAL_LANGUAGES[file_path.name]\n    ext = file_path.suffix\n    return LANGUAGE_MAP.get(ext, 'text')\n\n# ==============================\n# üöÄ EXPORTADOR PRINCIPAL\n# ==============================\n\ndef export_tiddlers(dry_run=False):\n    \"\"\"Recorre los archivos, detecta cambios y genera tiddlers si es necesario.\"\"\"\n\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    if HASH_FILE.exists():\n        with open(HASH_FILE, 'r', encoding='utf-8') as f:\n            old_hashes = json.load(f)\n    else:\n        old_hashes = {}\n\n    new_hashes = {}\n    changed_files = []\n\n    for file_path in get_all_files(ROOT_DIR):\n        rel_path = str(file_path.relative_to(ROOT_DIR))\n        lang = detect_language(file_path)\n\n        try:\n            content = file_path.read_text(encoding='utf-8')\n        except Exception as e:\n            print(f\"‚ö†Ô∏è Error leyendo {rel_path}: {e}\")\n            continue\n\n        hash_now = get_hash(content)\n        new_hashes[rel_path] = hash_now\n\n        if old_hashes.get(rel_path) == hash_now:\n            continue  # sin cambios\n\n        title = safe_title(file_path)\n        tags = tag_mapper.get_tags_for_file(file_path)  # üß¨ Tags desde OpenPages.json\n\n        # üß† Contenido markdown con tags visuales arriba\n        text_block = f\"## [[Tags]]\\n{' '.join(tags)}\\n\\n```{lang}\\n{content}\\n```\"\n\n        tiddler = {\n            \"title\": title,\n            \"text\": text_block,\n            \"tags\": ' '.join(tags),\n            \"type\": \"text/markdown\",\n            \"created\": datetime.now(timezone.utc).strftime('%Y%m%d%H%M%S%f')[:17],\n            \"modified\": datetime.now(timezone.utc).strftime('%Y%m%d%H%M%S%f')[:17],\n        }\n\n        if dry_run:\n            print(f\"[dry-run] Detectado cambio en: {rel_path}\")\n            continue\n\n        out_file = OUTPUT_DIR / f\"{title}.json\"\n        with open(out_file, 'w', encoding='utf-8') as f:\n            json.dump(tiddler, f, indent=2, ensure_ascii=False)\n\n        changed_files.append(rel_path)\n\n    if not dry_run:\n        with open(HASH_FILE, 'w', encoding='utf-8') as f:\n            json.dump(new_hashes, f, indent=2)\n\n    print(f\"\\nüì¶ Archivos modificados: {len(changed_files)}\")\n    if changed_files:\n        for path in changed_files:\n            print(f\"  ‚úÖ Exportado: {path}\")\n    else:\n        print(\"  üîÅ Sin cambios detectados.\")\n\n# ==============================\n# üß™ CLI: Entrada directa\n# ==============================\n\nif __name__ == \"__main__\":\n    import sys\n    dry = '--dry-run' in sys.argv\n    export_tiddlers(dry_run=dry)\n```",
  "tags": "[[--- üß¨ Por Clasificar]]",
  "type": "text/markdown",
  "created": "20250603172144474",
  "modified": "20250603172144474"
}