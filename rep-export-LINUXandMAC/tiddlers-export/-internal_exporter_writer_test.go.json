{
  "title": "-internal_exporter_writer_test.go",
  "text": "## [[Tags]]\n[[--- üß¨ Por Clasificar]]\n\n```go\n// internal/exporter/writer_test.go ‚Äì Tests para exporter.WriteJSONL\n// --------------------------------------------------------------------------------\n// Comprueba dos rutas:\n//   1. √âxito: archivo temporal + 2 records ‚Üí 2 l√≠neas JSONL id√©nticas.\n//   2. Falla: ruta imposible debe devolver error.\n// --------------------------------------------------------------------------------\n//\n// --------------------------------------------------------------------------------\n// Verifica que la funci√≥n revisada (`records any, pretty bool`) maneje:\n//   ‚Ä¢ Slice v1   ‚Üí []models.Record.\n//   ‚Ä¢ Slice v2   ‚Üí []models.RecordV2.\n//   ‚Ä¢ Ruta inv√°lida ‚Üí error.\n// --------------------------------------------------------------------------------\n\npackage exporter\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"os\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/diegoabeltran16/OpenPages-Source/models\"\n)\n\n// tmpPath genera un archivo temporal y devuelve la ruta.\nfunc tmpPath(t *testing.T) string {\n\tt.Helper()\n\tf, err := os.CreateTemp(\"\", \"out-*.jsonl\")\n\tif err != nil {\n\t\tt.Fatalf(\"tmpPath: %v\", err)\n\t}\n\tname := f.Name()\n\tf.Close()\n\treturn name\n}\n\n// ----------------------------- caso √©xito v1 -----------------------------\nfunc TestWriteJSONL_V1(t *testing.T) {\n\trecs := []models.Record{\n\t\t{ID: \"A\", Tags: []string{\"x\"}, ContentType: \"text/plain\", TextPlain: \"foo\"},\n\t\t{ID: \"B\", Tags: []string{\"y\"}, ContentType: \"text/plain\", TextPlain: \"bar\"},\n\t}\n\tpath := tmpPath(t)\n\tdefer os.Remove(path)\n\n\tif err := WriteJSONL(context.Background(), path, recs, false); err != nil {\n\t\tt.Fatalf(\"WriteJSONL v1 err: %v\", err)\n\t}\n\n\tverifyLines(t, path, recs)\n}\n\n// ----------------------------- caso √©xito v2 -----------------------------\nfunc TestWriteJSONL_V2(t *testing.T) {\n\trecs := []models.RecordV2{\n\t\t{ID: \"1\", Type: \"tiddler\", Meta: models.Meta{Title: \"Hello\"}, Content: models.Content{Plain: \"hola\"}},\n\t\t{ID: \"2\", Type: \"tiddler\", Meta: models.Meta{Title: \"World\"}, Content: models.Content{Plain: \"mundo\"}},\n\t}\n\tpath := tmpPath(t)\n\tdefer os.Remove(path)\n\n\tif err := WriteJSONL(context.Background(), path, recs, false); err != nil {\n\t\tt.Fatalf(\"WriteJSONL v2 err: %v\", err)\n\t}\n\n\tverifyLines(t, path, recs)\n}\n\n// ----------------------------- ruta inv√°lida -----------------------------\nfunc TestWriteJSONL_InvalidPath(t *testing.T) {\n\terr := WriteJSONL(context.Background(), \"/no/existe/out.jsonl\", nil, false)\n\tif err == nil {\n\t\tt.Fatalf(\"esperaba error en ruta inv√°lida\")\n\t}\n}\n\n// ----------------------------- helper de verificaci√≥n --------------------\nfunc verifyLines(t *testing.T, path string, wantSlice any) {\n\tt.Helper()\n\tdata, _ := os.ReadFile(path)\n\tlines := strings.Split(strings.TrimSpace(string(data)), \"\\n\")\n\n\tv := reflect.ValueOf(wantSlice)\n\tif len(lines) != v.Len() {\n\t\tt.Fatalf(\"l√≠neas = %d, want %d\", len(lines), v.Len())\n\t}\n\tfor i, l := range lines {\n\t\tgotPtr := reflect.New(v.Type().Elem()) // *T\n\t\tif err := json.Unmarshal([]byte(l), gotPtr.Interface()); err != nil {\n\t\t\tt.Fatalf(\"unmarshal l√≠nea %d: %v\", i, err)\n\t\t}\n\t\tif !reflect.DeepEqual(gotPtr.Elem().Interface(), v.Index(i).Interface()) {\n\t\t\tt.Errorf(\"l√≠nea %d mismatch\\n got:  %+v\\n want: %+v\", i, gotPtr.Elem(), v.Index(i))\n\t\t}\n\t}\n}\n\n```",
  "tags": "[[--- üß¨ Por Clasificar]]",
  "type": "text/markdown",
  "created": "20250531224148703",
  "modified": "20250531224148703"
}