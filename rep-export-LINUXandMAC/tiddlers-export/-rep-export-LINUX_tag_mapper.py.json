{
  "title": "-rep-export-LINUX_tag_mapper.py",
  "text": "## [[Tags]]\n[[--- üß¨ Por Clasificar]]\n\n```python\n\"\"\"\nüì¶ M√≥dulo: tag_mapper.py\nüéØ Ubicaci√≥n esperada: rep-export-LINUX/tag_mapper.py\n\nüß† Funci√≥n:\nEste m√≥dulo se encarga de asignar tags sem√°nticos a archivos del proyecto,\nbas√°ndose en uno o varios archivos JSON alojados dentro de `tiddler_tag_doc/`.\nCualquiera que sea el nombre del JSON, si termina en `.json` dentro de la carpeta,\nse cargar√° y se a√±adir√° a la lista de entradas sem√°nticas.\n\n‚ú® Comportamiento:\n  - Busca la carpeta `tiddler_tag_doc/` en el mismo nivel de este script.\n  - Recorre todos los archivos `*.json` dentro de esa carpeta.\n  - Si la carpeta no existe o no hay JSON, emite un aviso pero contin√∫a sin tags personalizados.\n  - Si un JSON est√° mal formado, emite un aviso y lo omite, pero carga los dem√°s.\n  - Crea un √≠ndice global (clave: \"title\", valor: lista de tags) combinando todos los JSON v√°lidos.\n  - Si un archivo no se encuentra en el √≠ndice final, retorna `['[[--- üß¨ Por Clasificar]]']`.\n\"\"\"\n\nimport json\nfrom pathlib import Path\nimport os\n\n# ===================================\n# ‚öôÔ∏è CONFIGURACI√ìN: ruta a la carpeta\n# ===================================\n# Asumimos que este script est√° en rep-export-LINUX/tag_mapper.py,\n# por lo que el directorio \"tiddler_tag_doc\" est√° en el mismo nivel que este archivo.\nTIDDLER_TAG_DIR = Path(__file__).resolve().parents[0] / \"tiddler_tag_doc\"\n\n# =====================================\n# üì• CARGA DE TODOS LOS JSON EN tiddler_tag_doc\n# =====================================\ntag_data = []  # Ac√° acumularemos todas las entradas de JSON\n\nif TIDDLER_TAG_DIR.exists() and TIDDLER_TAG_DIR.is_dir():\n    # Buscamos todos los archivos con extensi√≥n .json en orden alfab√©tico\n    json_files = sorted(TIDDLER_TAG_DIR.glob(\"*.json\"))\n    if not json_files:\n        print(f\"‚ö†Ô∏è No se encontraron archivos .json en: {TIDDLER_TAG_DIR}\")\n    else:\n        for json_path in json_files:\n            try:\n                with open(json_path, 'r', encoding='utf-8') as f:\n                    data = json.load(f)\n                    if isinstance(data, list):\n                        # Si el JSON es una lista de objetos, lo agregamos\n                        tag_data.extend(data)\n                    else:\n                        print(f\"‚ö†Ô∏è El contenido de '{json_path.name}' no es una lista JSON v√°lida. Se omitir√°.\")\n            except json.JSONDecodeError:\n                print(f\"‚ö†Ô∏è El archivo existe pero no es un JSON v√°lido: {json_path}\")\n            except Exception as e:\n                print(f\"‚ö†Ô∏è Error al leer '{json_path.name}': {e}\")\nelse:\n    print(f\"‚ö†Ô∏è No se encontr√≥ la carpeta tiddler_tag_doc en: {TIDDLER_TAG_DIR}\")\n\n# ============================================================\n# üìë Construir √≠ndice global: t√≠tulo (string) ‚Üí lista de tags\n# ============================================================\n# Cada objeto en tag_data deber√≠a tener al menos:\n#   { \"title\": \"-ruta_relativa_al_archivo\", \"tags\": \"[[TagA]] [[TagB]]\" }\n# Si no cumple, simplemente lo saltamos.\ntitle_to_tags: dict[str, list[str]] = {}\n\nfor item in tag_data:\n    if not isinstance(item, dict):\n        continue  # saltamos cualquier cosa que no sea un dict\n    title = item.get(\"title\", \"\").strip()\n    tags_str = item.get(\"tags\", \"\")\n    if title and isinstance(tags_str, str):\n        # Convertimos la cadena de tags en lista\n        tags_list = tags_str.split()\n        title_to_tags[title] = tags_list\n\n# ================================================================\n# üîé FUNCI√ìN PRINCIPAL: obtener lista de tags para un archivo dado\n# ================================================================\ndef get_tags_for_file(file_path: Path) -> list[str]:\n    \"\"\"\n    Dado un Path absoluto (o relativo) de un archivo dentro del repo,\n    construye el 't√≠tulo' (matching con los JSON) y retorna la lista de tags.\n    Si no lo encuentra en el √≠ndice, retorna ['[[--- üß¨ Por Clasificar]]'].\n\n    Ejemplo de construcci√≥n de t√≠tulo:\n      Si file_path = /.../src/utils/helpers.py\n      y el ROOT (para el √≠ndice) es un nivel arriba de este script,\n      entonces rel_title = \"-src_utils_helpers.py\"\n\n    Par√°metros:\n    - file_path: Path hacia el archivo real en el repositorio.\n\n    Retorna:\n    - List[str]: lista de tags (p.ej. [\"[[TagA]]\", \"[[TagB]]\"]) o\n                 ['[[--- üß¨ Por Clasificar]]'] si no existe.\n    \"\"\"\n    try:\n        # Determinar carpeta ra√≠z del repo (dos niveles arriba de este script)\n        root_dir = Path(__file__).resolve().parents[1]\n        rel_path_unix = str(file_path.relative_to(root_dir)).replace(os.sep, '_')\n        rel_title = \"-\" + rel_path_unix\n    except Exception:\n        # Si no se puede calcular la ruta relativa, asignamos prefijo por defecto\n        rel_title = \"-\" + file_path.name\n\n    # Devolvemos los tags si existen en el √≠ndice, o el fallback si no\n    return title_to_tags.get(rel_title, ['[[--- üß¨ Por Clasificar]]'])\n\n```",
  "tags": "[[--- üß¨ Por Clasificar]]",
  "type": "text/markdown",
  "created": "20250531223113417",
  "modified": "20250531223113417"
}