{
  "title": "-internal_exporter_writer.go",
  "text": "## [[Tags]]\n[[--- ðŸ§¬ Por Clasificar]]\n\n```go\n// internal/exporter/writer.go â€“ Persistencia de records en JSONL\n// --------------------------------------------------------------------------------\n// Contexto pedagÃ³gico\n// -------------------\n// Este archivo vive en el paquete **exporter** dentro de `internal/`.  Expone\n// `WriteJSONL`, la pieza final del pipeline (importer â†’ transform â†’ exporter).\n// Su misiÃ³n es volcar `[]models.Record` al disco usando el formato **JSONL**\n// (una lÃ­nea JSON compacta por registro).\n//\n// Cambios respecto a la versiÃ³n monolÃ­tica:\n//   â€¢ paquete `exporter` (no `main`).\n//   â€¢ Firma ahora acepta `context.Context` para futuras cancelaciones.\n//   â€¢ CÃ³digo sigue 100â€¯% determinista: si algo falla, retorna `error`.\n// --------------------------------------------------------------------------------\n//\n// Cambios clave\n//   â€¢ Firma: WriteJSONL(ctx, path, records any, pretty bool)\n//   â€¢ `records` debe ser un slice (v1 o v2) â€“ se itera vÃ­a reflect.\n//   â€¢ Flag `pretty` decide entre Marshal y MarshalIndent.\n// --------------------------------------------------------------------------------\n\npackage exporter\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"reflect\"\n)\n\n// WriteJSONL serializa cualquier slice de structs a JSONL.\n//\n//   - records â€“ debe ser un slice (p. ej. []models.Record o []models.RecordV2)\n//   - pretty  â€“ true â†’ MarshalIndent (legible); false â†’ Marshal (compacto)\nfunc WriteJSONL(ctx context.Context, path string, records any, pretty bool) error {\n\t_ = ctx // reservado para cancelaciones futuras\n\n\tv := reflect.ValueOf(records)\n\tif v.Kind() != reflect.Slice {\n\t\treturn errors.New(\"records debe ser slice\")\n\t}\n\n\tfile, err := os.Create(path)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"crear '%s': %w\", path, err)\n\t}\n\tdefer func() {\n\t\tif cerr := file.Close(); cerr != nil && err == nil {\n\t\t\terr = fmt.Errorf(\"cerrar '%s': %w\", path, cerr)\n\t\t}\n\t}()\n\n\tw := bufio.NewWriter(file)\n\n\tfor i := 0; i < v.Len(); i++ {\n\t\tif ctx.Err() != nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\t\telem := v.Index(i).Interface()\n\n\t\tvar line []byte\n\t\tif pretty {\n\t\t\tline, err = json.MarshalIndent(elem, \"\", \"  \")\n\t\t} else {\n\t\t\tline, err = json.Marshal(elem)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"marshal elemento %d: %w\", i, err)\n\t\t}\n\t\tif _, err := w.Write(line); err != nil {\n\t\t\treturn fmt.Errorf(\"escribir elemento %d: %w\", i, err)\n\t\t}\n\t\tif err := w.WriteByte('\\n'); err != nil {\n\t\t\treturn fmt.Errorf(\"newline elemento %d: %w\", i, err)\n\t\t}\n\t}\n\n\tif err := w.Flush(); err != nil {\n\t\treturn fmt.Errorf(\"flush: %w\", err)\n\t}\n\treturn nil\n}\n\n```",
  "tags": "[[--- ðŸ§¬ Por Clasificar]]",
  "type": "text/markdown",
  "created": "20250531224148703",
  "modified": "20250531224148703"
}