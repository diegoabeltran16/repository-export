{
  "title": "-rep-export-LINUX_tiddler_exporter.py",
  "text": "## [[Tags]]\n[[--- üß¨ Por Clasificar]]\n\n```python\n\"\"\"\nüì¶ Script: tiddler_exporter.py\nüìç Ubicaci√≥n: rep-export-LINUX/tiddler_exporter.py\n\nüß† Funci√≥n:\nEste script recorre todos los archivos fuente del proyecto, detecta si su contenido ha cambiado,\ny si es as√≠, genera un archivo `.json` (un tiddler en formato TiddlyWiki) listo para importar.\n\nüîñ Cada archivo se convierte en un \"tiddler\", con:\n  - Nombre prefijado con `-` (ej: -src_logger.py)\n  - Tags sem√°nticos obtenidos desde `OpenPages.json` a trav√©s de `tag_mapper.py`\n  - Bloque markdown con el contenido del archivo y resaltado seg√∫n su lenguaje\n\nüéØ Compatible con TiddlyWiki, offline, AI-ready y 100% Python puro.\n\n‚úÖ C√≥mo ejecutarlo:\n\n    # Exporta solo si hay cambios detectados\n    python3 rep-export-LINUX/tiddler_exporter.py\n\n    # Modo simulaci√≥n (solo imprime qu√© archivos cambiar√≠an)\n    python3 rep-export-LINUX/tiddler_exporter.py --dry-run\n\"\"\"\n\nimport os\nimport json\nimport hashlib\nimport tag_mapper  # Importa la l√≥gica de tags desde scripts/tag_mapper.py\nfrom datetime import datetime, timezone\nfrom pathlib import Path\nfrom typing import List\n\n# ==========================\n# ‚öôÔ∏è CONFIGURACI√ìN GENERAL\n# ==========================\n\n# __file__ = rep-export-LINUX/tiddler_exporter.py\n# ROOT_DIR apunta a la carpeta ra√≠z del repositorio (dos niveles arriba de este script)\nROOT_DIR = Path(__file__).resolve().parents[1]\nSCRIPT_DIR = Path(__file__).parent\nOUTPUT_DIR = SCRIPT_DIR / \"tiddlers-export\"  # Carpeta donde se escribir√°n los tiddlers JSON\nHASH_FILE = SCRIPT_DIR / \".hashes.json\"       # Archivo que almacena hashes previos para detectar cambios\n\n# Extensiones v√°lidas (archivos que queremos convertir a tiddlers)\nVALID_EXTENSIONS = ['.py', '.md', '.json', '.sh', '.html', '.css', '.yml', '.txt','.go']\n# Archivos sin extensi√≥n que queremos incluir (ej. .gitignore)\nALLOWED_FILENAMES = ['.gitignore']\n\n# Carpetas que NO queremos recorrer (ignorar)\nIGNORE_DIRS = [\n    '__pycache__', 'venv', '.venv', 'dist', 'node_modules', 'output', 'input',\n    '.pytest_cache', 'configs', 'media', 'project_details', 'tiddlers-export'\n]\n\n# Mapa para determinar el lenguaje de resaltado al generar el bloque markdown\nLANGUAGE_MAP = {\n    '.py': 'python',\n    '.md': 'markdown',\n    '.json': 'json',\n    '.sh': 'bash',\n    '.yml': 'bash',\n    '.html': 'html',\n    '.txt': 'txt',\n    '.css': 'css',\n    '.go' : 'go'\n}\n\n# Mapa para archivos especiales por nombre (ej. .gitignore)\nSPECIAL_LANGUAGES = {\n    '.gitignore': 'gitignore'\n}\n\n# ==============================\n# üîé FUNCIONES AUXILIARES\n# ==============================\n\ndef get_all_files(directory: Path) -> List[Path]:\n    \"\"\"\n    Recorre recursivamente 'directory' y devuelve una lista de Path\n    solo con archivos v√°lidos (seg√∫n VALID_EXTENSIONS o ALLOWED_FILENAMES),\n    saltando carpetas definidas en IGNORE_DIRS.\n    \"\"\"\n    all_files: List[Path] = []\n    for root, dirs, files in os.walk(directory):\n        # Filtramos directorios ignorados\n        dirs[:] = [d for d in dirs if d not in IGNORE_DIRS]\n        for filename in files:\n            ext = Path(filename).suffix\n            if ext in VALID_EXTENSIONS or filename in ALLOWED_FILENAMES:\n                all_files.append(Path(root) / filename)\n    return all_files\n\ndef get_hash(content: str) -> str:\n    \"\"\"\n    Recibe una cadena (\"content\") y retorna su hash SHA-1 en hexadecimal.\n    Se usa para detectar cambios en el contenido de archivos.\n    \"\"\"\n    return hashlib.sha1(content.encode('utf-8')).hexdigest()\n\ndef safe_title(path: Path) -> str:\n    \"\"\"\n    Dado un Path absoluto o relativo dentro de ROOT_DIR,\n    retorna un t√≠tulo v√°lido para un tiddler:\n      - Prefijo \"-\" (para cumplir con convenci√≥n TiddlyWiki).\n      - Reemplazo de separadores por gui√≥n bajo.\n    Ejemplo: si 'path' es /repo/src/utils/helpers.py,\n    y ROOT_DIR = /repo, title ser√° \"-src_utils_helpers.py\"\n    \"\"\"\n    return '-' + str(path.relative_to(ROOT_DIR)).replace(os.sep, '_')\n\ndef detect_language(file_path: Path) -> str:\n    \"\"\"\n    Determina el lenguaje para el bloque de c√≥digo en markdown:\n      - Si el nombre del archivo est√° en SPECIAL_LANGUAGES, lo retorna.\n      - En otro caso, busca la extensi√≥n en LANGUAGE_MAP.\n      - Si no lo encuentra, usa \"text\" por defecto.\n    \"\"\"\n    name = file_path.name\n    if name in SPECIAL_LANGUAGES:\n        return SPECIAL_LANGUAGES[name]\n    ext = file_path.suffix\n    return LANGUAGE_MAP.get(ext, 'text')\n\n# ==============================\n# üöÄ EXPORTADOR PRINCIPAL\n# ==============================\n\ndef export_tiddlers(dry_run: bool = False):\n    \"\"\"\n    Recorre todos los archivos v√°lidos en ROOT_DIR, calcula su hash y\n    comprueba si ha cambiado desde la √∫ltima ejecuci√≥n (almacenada en .hashes.json).\n\n    Para cada archivo que cambi√≥:\n      1. Genera un \"title\" v√°lido con safe_title().\n      2. Obtiene sus tags usando tag_mapper.get_tags_for_file().\n      3. Construye el contenido markdown del tiddler (con bloque de c√≥digo).\n      4. Escribe un JSON de tiddler en OUTPUT_DIR (salvo que sea dry_run).\n      5. Actualiza la lista de archivos modificados.\n\n    Par√°metros:\n    - dry_run: Si es True, solo imprime qu√© archivos cambiar√≠an, sin escribir nada.\n    \"\"\"\n    # Asegurarse de que OUTPUT_DIR existe\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n\n    # Cargar hashes anteriores (si existe .hashes.json); sino, empezar con dict vac√≠o\n    if HASH_FILE.exists():\n        try:\n            with open(HASH_FILE, 'r', encoding='utf-8') as f:\n                old_hashes = json.load(f)\n        except Exception:\n            print(f\"‚ö†Ô∏è No se pudo leer {HASH_FILE}. Se re-iniciar√°n todos los hashes.\")\n            old_hashes = {}\n    else:\n        old_hashes = {}\n\n    new_hashes: dict[str, str] = {}\n    changed_files: List[str] = []\n\n    # Recorrer cada archivo v√°lido en el repositorio\n    for file_path in get_all_files(ROOT_DIR):\n        # Ruta relativa como string (ej: \"src/utils/helpers.py\")\n        rel_path = str(file_path.relative_to(ROOT_DIR))\n\n        # Detectar lenguaje para resaltar c√≥digo en markdown\n        lang = detect_language(file_path)\n\n        # Leer contenido del archivo\n        try:\n            content = file_path.read_text(encoding='utf-8')\n        except Exception as e:\n            print(f\"‚ö†Ô∏è Error leyendo {rel_path}: {e}\")\n            # Si no pudo leer, saltar este archivo\n            continue\n\n        # Calcular hash SHA1 del contenido\n        hash_now = get_hash(content)\n        new_hashes[rel_path] = hash_now\n\n        # Si el hash coincide con el anterior, no hubo cambios ‚Üí saltar\n        if old_hashes.get(rel_path) == hash_now:\n            continue\n\n        # ---------- Ha habido cambio (o es primera vez) ----------\n        # 1) Construir t√≠tulo\n        title = safe_title(file_path)\n\n        # 2) Obtener tags sem√°nticos (o tag por defecto si no existe JSON)\n        tags_list = tag_mapper.get_tags_for_file(file_path)\n        tags_joined = ' '.join(tags_list)\n\n        # 3) Construir bloque de texto Markdown para el tiddler\n        #    - Encabezado con secci√≥n Tags\n        #    - Luego bloque de c√≥digo con el contenido real\n        text_block = (\n            \"## [[Tags]]\\n\"\n            f\"{tags_joined}\\n\\n\"\n            f\"```{lang}\\n\"\n            f\"{content}\\n\"\n            \"```\"\n        )\n\n        # 4) Crear estructura JSON del tiddler\n        tiddler = {\n            \"title\": title,\n            \"text\": text_block,\n            \"tags\": tags_joined,\n            \"type\": \"text/markdown\",\n            # Fechas en formato TiddlyWiki: YYYYMMDDhhmmssSSS (milisegundos)\n            \"created\": datetime.now(timezone.utc).strftime('%Y%m%d%H%M%S%f')[:17],\n            \"modified\": datetime.now(timezone.utc).strftime('%Y%m%d%H%M%S%f')[:17],\n        }\n\n        # Si estamos en modo simulaci√≥n, imprimimos y saltamos escritura\n        if dry_run:\n            print(f\"[dry-run] Detectado cambio en: {rel_path}\")\n            continue\n\n        # 5) Escribir archivo JSON dentro de OUTPUT_DIR\n        out_file = OUTPUT_DIR / f\"{title}.json\"\n        try:\n            with open(out_file, 'w', encoding='utf-8') as f:\n                json.dump(tiddler, f, indent=2, ensure_ascii=False)\n        except Exception as e:\n            print(f\"‚ö†Ô∏è No se pudo escribir {out_file}: {e}\")\n            continue\n\n        # Agregar a la lista de archivos modificados (para reportar al final)\n        changed_files.append(rel_path)\n\n    # ======= Actualizar archivo de hashes si no es dry_run =======\n    if not dry_run:\n        try:\n            with open(HASH_FILE, 'w', encoding='utf-8') as f:\n                json.dump(new_hashes, f, indent=2)\n        except Exception as e:\n            print(f\"‚ö†Ô∏è No se pudo actualizar {HASH_FILE}: {e}\")\n\n    # ======= Informe final =======\n    print(f\"\\nüì¶ Archivos modificados: {len(changed_files)}\")\n    if changed_files:\n        for path in changed_files:\n            print(f\"  ‚úÖ Exportado: {path}\")\n    else:\n        print(\"  üîÅ Sin cambios detectados.\")\n        \n\n# ==============================\n# üß™ CLI: Entrada directa\n# ==============================\nif __name__ == \"__main__\":\n    import sys\n    # Detectar bandera --dry-run\n    dry = '--dry-run' in sys.argv\n    export_tiddlers(dry_run=dry)\n\n```",
  "tags": "[[--- üß¨ Por Clasificar]]",
  "type": "text/markdown",
  "created": "20250531224148705",
  "modified": "20250531224148705"
}