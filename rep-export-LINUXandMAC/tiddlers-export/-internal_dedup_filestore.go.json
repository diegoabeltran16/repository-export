{
  "title": "-internal_dedup_filestore.go",
  "text": "## [[Tags]]\n[[--- ðŸ§¬ Por Clasificar]]\n\n```go\npackage dedup\n\nimport (\n\t\"bufio\"\n\t\"os\"\n\t\"sync\"\n)\n\n// FileStore mantiene los hashes en un archivo append-only.\n// Formato: un hash (hex) por lÃ­nea.\ntype FileStore struct {\n\tmu     sync.RWMutex\n\tset    map[string]struct{}\n\tfile   *os.File\n\twriter *bufio.Writer\n}\n\n// NewFileStore abre (o crea) el archivo y carga los hashes existentes.\nfunc NewFileStore(path string) (*FileStore, error) {\n\tf, err := os.OpenFile(path, os.O_CREATE|os.O_RDWR, 0o600)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfs := &FileStore{\n\t\tset:    make(map[string]struct{}),\n\t\tfile:   f,\n\t\twriter: bufio.NewWriter(f),\n\t}\n\n\t// Cargar hashes previos\n\tscanner := bufio.NewScanner(f)\n\tfor scanner.Scan() {\n\t\tfs.set[scanner.Text()] = struct{}{}\n\t}\n\t// Reposicionar al final para append\n\tif _, err := f.Seek(0, os.SEEK_END); err != nil {\n\t\tf.Close()\n\t\treturn nil, err\n\t}\n\treturn fs, scanner.Err()\n}\n\nfunc (fs *FileStore) Seen(h string) bool {\n\tfs.mu.RLock()\n\t_, ok := fs.set[h]\n\tfs.mu.RUnlock()\n\treturn ok\n}\n\nfunc (fs *FileStore) Mark(h string) error {\n\tfs.mu.Lock()\n\tif _, exists := fs.set[h]; !exists {\n\t\tif _, err := fs.writer.WriteString(h + \"\\n\"); err != nil {\n\t\t\tfs.mu.Unlock()\n\t\t\treturn err\n\t\t}\n\t\tfs.set[h] = struct{}{}\n\t}\n\tfs.mu.Unlock()\n\treturn nil\n}\n\nfunc (fs *FileStore) Close() error {\n\tfs.mu.Lock()\n\tdefer fs.mu.Unlock()\n\tif err := fs.writer.Flush(); err != nil {\n\t\tfs.file.Close()\n\t\treturn err\n\t}\n\treturn fs.file.Close()\n}\n\n```",
  "tags": "[[--- ðŸ§¬ Por Clasificar]]",
  "type": "text/markdown",
  "created": "20250531224148701",
  "modified": "20250531224148701"
}