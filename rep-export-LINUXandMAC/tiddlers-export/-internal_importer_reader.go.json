{
  "title": "-internal_importer_reader.go",
  "text": "## [[Tags]]\n[[--- üß¨ Por Clasificar]]\n\n```go\n// internal/importer/reader.go ‚Äì Lectura de tiddlers desde JSON exportado de TiddlyWiki\n// ----------------------------------------------------------------------------------------------------\n// Contexto pedag√≥gico\n// -------------------\n// Este archivo vive en el paquete **importer** dentro de `internal/`, por lo que no se puede importar\n// desde fuera del m√≥dulo.  Expone la funci√≥n `Read`, encargada de convertir un export de TiddlyWiki\n// (JSON) en un slice de `models.Tiddler` homog√©neo.\n//\n// Firma p√∫blica:\n//   Read(ctx context.Context, path string) ([]models.Tiddler, error)\n//\n// ¬∑¬†`ctx` permite, en una futura versi√≥n streaming, cancelar la operaci√≥n.\n// ¬∑¬†`path` es la ruta del archivo a leer.\n//\n// El algoritmo detecta autom√°ticamente dos formatos de exportaci√≥n:\n//   1. Array JSON   ‚Üí `[ {...}, {...} ]`\n//   2. Objeto plano ‚Üí `{ \"id\": {...}, \"id2\": {...} }`\n// ----------------------------------------------------------------------------------------------------\n\npackage importer\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/diegoabeltran16/OpenPages-Source/models\"\n)\n\n// Read abre y deserializa el archivo indicado en `path`.\n//\n// Valores de retorno\n// ------------------\n//   - []models.Tiddler ‚Äì tiddlers listos para procesar aguas abajo.\n//   - error            ‚Äì nil en √©xito; descriptivo en caso de fallo.\nfunc Read(ctx context.Context, path string) ([]models.Tiddler, error) {\n\t// Por el momento `ctx` no se usa porque la lectura se hace de un solo golpe.\n\t// Se acepta como par√°metro para soportar cancelaciones cuando se implemente\n\t// el modo streaming con json.Decoder.\n\t_ = ctx\n\n\t// ---------------------------------------------------------------------\n\t// 1) Lectura de archivo completo\n\t// ---------------------------------------------------------------------\n\tdata, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"no se pudo leer el archivo '%s': %w\", path, err)\n\t}\n\n\t// ---------------------------------------------------------------------\n\t// 2) Intento: array JSON\n\t// ---------------------------------------------------------------------\n\tvar list []models.Tiddler\n\tif err := json.Unmarshal(data, &list); err == nil {\n\t\tif len(list) == 0 {\n\t\t\tfmt.Println(\"‚ö†Ô∏è  Archivo v√°lido, pero el array de tiddlers est√° vac√≠o.\")\n\t\t}\n\t\treturn list, nil\n\t}\n\n\t// ---------------------------------------------------------------------\n\t// 3) Intento: objeto plano (map)\n\t// ---------------------------------------------------------------------\n\tvar mp map[string]models.Tiddler\n\tif err := json.Unmarshal(data, &mp); err == nil {\n\t\ttiddlers := make([]models.Tiddler, 0, len(mp))\n\t\tfor _, t := range mp {\n\t\t\ttiddlers = append(tiddlers, t)\n\t\t}\n\t\tif len(tiddlers) == 0 {\n\t\t\tfmt.Println(\"‚ö†Ô∏è  Archivo v√°lido, pero el mapa de tiddlers est√° vac√≠o.\")\n\t\t}\n\t\treturn tiddlers, nil\n\t}\n\n\t// ---------------------------------------------------------------------\n\t// 4) Formato desconocido\n\t// ---------------------------------------------------------------------\n\treturn nil, fmt.Errorf(\"error al parsear JSON de tiddlers: no es ni array ni objeto plano v√°lido\")\n}\n\n```",
  "tags": "[[--- üß¨ Por Clasificar]]",
  "type": "text/markdown",
  "created": "20250531224148702",
  "modified": "20250531224148702"
}