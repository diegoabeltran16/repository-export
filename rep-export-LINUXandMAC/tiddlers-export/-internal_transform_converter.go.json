{
  "title": "-internal_transform_converter.go",
  "text": "## [[Tags]]\n[[--- üß¨ Por Clasificar]]\n\n```go\n// internal/transform/converter.go ‚Äì v1 + v2\n// --------------------------------------------------------------------------------\n// Este archivo ahora expone **dos** funciones p√∫blicas:\n//   ‚Ä¢ ConvertTiddlers   ‚Üí genera []models.Record     (esquema heredado).\n//   ‚Ä¢ ConvertTiddlersV2 ‚Üí genera []models.RecordV2   (nuevo esquema AI‚Äëfriendly).\n// Ambas conviven para permitir que el CLI elija entre `-mode v1` y `-mode v2`.\n// --------------------------------------------------------------------------------\n\npackage transform\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"regexp\"\n\t\"time\"\n\n\t\"github.com/diegoabeltran16/OpenPages-Source/models\"\n)\n\n// -----------------------------------------------------------------------------\n// Utilidades compartidas\n// -----------------------------------------------------------------------------\n\nvar tagRe = regexp.MustCompile(`\\[\\[([^]]+)\\]\\]`)\n\nfunc parseTags(raw string) []string {\n\tmatches := tagRe.FindAllStringSubmatch(raw, -1)\n\ttags := make([]string, 0, len(matches))\n\tfor _, m := range matches {\n\t\tif len(m) > 1 {\n\t\t\ttags = append(tags, m[1])\n\t\t}\n\t}\n\treturn tags\n}\n\n// TiddlyWiki suele usar yyyymmddhhMMSSmmm o yyyymmdd.\nfunc parseTWDate(raw string) (time.Time, bool) {\n\tlayouts := []string{\"20060102150405\", \"20060102\"}\n\tfor _, l := range layouts {\n\t\tif t, err := time.Parse(l, raw); err == nil {\n\t\t\treturn t, true\n\t\t}\n\t}\n\treturn time.Time{}, false\n}\n\n// -----------------------------------------------------------------------------\n// Versi√≥n 1 ‚Äì l√≥gica intacta\n// -----------------------------------------------------------------------------\n\nfunc ConvertTiddlers(ts []models.Tiddler) []models.Record {\n\trecs := make([]models.Record, 0, len(ts))\n\n\tfor _, t := range ts {\n\t\trec := models.Record{\n\t\t\tID:          t.Title,\n\t\t\tTags:        parseTags(t.Tags),\n\t\t\tContentType: t.Type,\n\t\t\tCreatedAt:   t.Created,\n\t\t\tModifiedAt:  t.Modified,\n\t\t}\n\n\t\tif t.Type == \"application/json\" {\n\t\t\tvar buf bytes.Buffer\n\t\t\tif err := json.Indent(&buf, []byte(t.Text), \"\", \"  \"); err == nil {\n\t\t\t\trec.TextMarkdown = buf.String()\n\t\t\t\trec.TextPlain = buf.String()\n\t\t\t} else {\n\t\t\t\trec.TextMarkdown = t.Text\n\t\t\t\trec.TextPlain = t.Text\n\t\t\t}\n\t\t} else {\n\t\t\trec.TextMarkdown = t.Text\n\t\t\trec.TextPlain = t.Text\n\t\t}\n\t\trecs = append(recs, rec)\n\t}\n\treturn recs\n}\n\n// -----------------------------------------------------------------------------\n// Versi√≥n 2 ‚Äì esquema meta/content\n// -----------------------------------------------------------------------------\n\nfunc ConvertTiddlersV2(ts []models.Tiddler) []models.RecordV2 {\n\trecs := make([]models.RecordV2, 0, len(ts))\n\n\tfor _, t := range ts {\n\t\t// Meta\n\t\tcreated, _ := parseTWDate(t.Created)\n\t\tmodified, _ := parseTWDate(t.Modified)\n\n\t\tmeta := models.Meta{\n\t\t\tTitle:    t.Title,\n\t\t\tTags:     parseTags(t.Tags),\n\t\t\tCreated:  created,\n\t\t\tModified: modified,\n\t\t\tColor:    t.Color,\n\t\t\tExtra: map[string]string{\n\t\t\t\t\"tmap.id\": t.TmapID,\n\t\t\t},\n\t\t}\n\n\t\t// Content\n\t\tvar content models.Content\n\t\tswitch t.Type {\n\t\tcase \"application/json\":\n\t\t\tvar obj map[string]any\n\t\t\tif err := json.Unmarshal([]byte(t.Text), &obj); err == nil {\n\t\t\t\tcontent.JSON = obj\n\t\t\t} else {\n\t\t\t\tcontent.Plain = t.Text\n\t\t\t}\n\t\tcase \"text/x-markdown\":\n\t\t\tcontent.Markdown = t.Text\n\t\tdefault: // text/plain y otros\n\t\t\tcontent.Plain = t.Text\n\t\t}\n\n\t\trec := models.RecordV2{\n\t\t\tID:      t.Title,   // se podr√≠a slugificar; se deja igual por simplicidad\n\t\t\tType:    \"tiddler\", // valor fijo; futuros conversores pueden clasificar\n\t\t\tMeta:    meta,\n\t\t\tContent: content,\n\t\t\t// Relations pendiente: populate si tu Tiddler trae esa info\n\t\t}\n\t\trecs = append(recs, rec)\n\t}\n\treturn recs\n}\n\n```",
  "tags": "[[--- üß¨ Por Clasificar]]",
  "type": "text/markdown",
  "created": "20250531224148702",
  "modified": "20250531224148702"
}