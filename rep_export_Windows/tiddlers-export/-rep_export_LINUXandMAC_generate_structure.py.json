{
  "title": "-rep_export_LINUXandMAC_generate_structure.py",
  "text": "## [[Tags]]\n[[‚öôÔ∏è Python]] [[-rep_export_LINUXandMAC_generate_structure.py]] [[--- Codigo]]\n\n```Python\n#!/usr/bin/env python3\n\"\"\"\nScript: generate_structure.py\nPlataformas objetivo: Linux y macOS\n\nGenera un archivo `estructura.txt` que muestra el √°rbol completo\nfiltrado del repositorio usando solo caracteres ASCII y codificado en UTF-8.\nAdmite exclusiones sensibles y respetar .gitignore, as√≠ como ejecuci√≥n en \"dry-run\".\n\nUso:\n  python3 generate_structure.py [--output PATH]\n                               [--honor-gitignore]\n                               [-e PATRON ...] [--exclude-from FILE]\n                               [--dry-run] [-v]\n\"\"\"\nimport os\nimport sys\nimport argparse\nimport logging\nimport tempfile\nfrom pathlib import Path\nfrom pathspec import PathSpec\nfrom fnmatch import fnmatch\n\n# Exclusiones por defecto\nIGNORED_DIRS = {\n    '.git', '.svn', '.hg', '.idea', 'node_modules',\n    'dist', 'build', 'venv', '.mypy_cache', '__pycache__'\n}\nIGNORED_FILES = {'.DS_Store'}\nIGNORED_EXT = {\n    '.pyc', '.class', '.o', '.exe', '.dll', '.so', '.dylib', '.pdb'\n}\n\n\ndef load_ignore_spec(repo_root: Path):\n    \"\"\"Carga PathSpec desde .gitignore si existe.\"\"\"\n    gitignore = repo_root / '.gitignore'\n    if not gitignore.is_file():\n        return None\n    lines = [\n        ln.strip() for ln in gitignore.read_text(encoding='utf-8').splitlines()\n        if ln.strip() and not ln.strip().startswith('#')\n    ]\n    if not lines:\n        return None\n    return PathSpec.from_lines('gitwildmatch', lines)\n\n\ndef should_skip(path: Path, repo_root: Path, exclude_patterns, honor_gitignore: bool, ignore_spec: PathSpec):\n    rel = str(path.relative_to(repo_root)).replace(\"\\\\\", \"/\")\n    # Excluye por defecto\n    name = path.name\n    if name in IGNORED_DIRS or name in IGNORED_FILES:\n        return True\n    if path.suffix.lower() in IGNORED_EXT:\n        return True\n    # Ocultos (excepto .gitignore)\n    if name.startswith('.') and name != '.gitignore':\n        return True\n    # Patrones extra\n    if exclude_patterns and any(fnmatch(rel, pat) for pat in exclude_patterns):\n        return True\n    # .gitignore (usando pathspec)\n    if honor_gitignore and ignore_spec and ignore_spec.match_file(rel):\n        # Excepciones: siempre incluir .gitignore y estructura.txt\n        if rel in ('.gitignore', 'estructura.txt'):\n            return False\n        return True\n    return False\n\n\ndef ascii_tree(root: Path, repo_root: Path, prefix='', args=None, ignore_spec=None):\n    \"\"\"Construye lista de l√≠neas con √°rbol ASCII filtrado\"\"\"\n    exclude_patterns = getattr(args, 'exclude', []) or []\n    honor_gitignore = getattr(args, 'honor_gitignore', False)\n\n    lines = []\n    try:\n        entries = sorted(root.iterdir(), key=lambda p: p.name.lower())\n    except PermissionError:\n        logging.warning(f\"Permiso denegado: {root}\")\n        return lines\n\n    entries = [\n        e for e in entries\n        if not should_skip(e, repo_root, exclude_patterns, honor_gitignore, ignore_spec)\n    ]\n\n    for idx, entry in enumerate(entries):\n        connector = '‚îî‚îÄ‚îÄ ' if idx == len(entries) - 1 else '‚îú‚îÄ‚îÄ '\n        lines.append(f\"{prefix}{connector}{entry.name}\")\n        if entry.is_dir() and not entry.is_symlink():\n            extension = '    ' if idx == len(entries) - 1 else '‚îÇ   '\n            lines += ascii_tree(entry, repo_root, prefix + extension, args, ignore_spec)\n    return lines\n\n\ndef write_atomic(path: Path, lines):\n    \"\"\"Escribe de forma at√≥mica reemplazando el archivo destino.\"\"\"\n    tmp = tempfile.NamedTemporaryFile(\n        'w',\n        delete=False,\n        encoding='utf-8',\n        dir=path.parent\n    )\n    with tmp:\n        tmp.write('\\n'.join(lines))\n    Path(tmp.name).replace(path)\n    logging.info(f\"Estructura escrita en {path}\")\n\n\ndef parse_args():\n    p = argparse.ArgumentParser(\n        description=\"Genera un √°rbol ASCII del proyecto con exclusiones de privacidad.\"\n    )\n    p.add_argument(\n        '--output', '-o', type=Path, default=Path('estructura.txt'),\n        help=\"Archivo de destino (por defecto: <root>/estructura.txt)\"\n    )\n    p.add_argument(\n        '--honor-gitignore', action='store_true',\n        help=\"Excluir patrones listados en .gitignore\"\n    )\n    p.add_argument(\n        '-e', '--exclude', action='append', default=[],\n        help=\"Patr√≥n glob adicional a excluir (repetible)\"\n    )\n    p.add_argument(\n        '--exclude-from', type=Path,\n        help=\"Archivo con patrones glob a excluir (uno por l√≠nea)\"\n    )\n    p.add_argument(\n        '--dry-run', action='store_true',\n        help=\"Imprime √°rbol sin escribir archivo\"\n    )\n    p.add_argument(\n        '-v', '--verbose', action='count', default=0,\n        help=\"Aumenta nivel de detalle en logs\"\n    )\n    return p.parse_args()\n\n\ndef main():\n    args = parse_args()\n    level = logging.WARNING - (10 * args.verbose)\n    logging.basicConfig(level=level, format='[%(levelname)s] %(message)s')\n\n    repo_root = Path(__file__).resolve().parent\n    os.chdir(repo_root)\n\n    ignore_spec = load_ignore_spec(repo_root) if args.honor_gitignore else None\n\n    if args.exclude_from and args.exclude_from.is_file():\n        extra = [\n            line.strip() for line in\n            args.exclude_from.read_text(encoding='utf-8').splitlines()\n            if line.strip() and not line.startswith('#')\n        ]\n        args.exclude.extend(extra)\n\n    logging.info(f\"Generando estructura desde {repo_root}\")\n    lines = ascii_tree(\n        repo_root, repo_root, prefix='',\n        args=args, ignore_spec=ignore_spec\n    )\n\n    if args.dry_run:\n        print('\\n'.join(lines))\n        logging.info(\"[dry-run] no se escribi√≥ archivo\")\n        return\n\n    output_path = args.output if args.output.is_absolute() else repo_root / args.output\n    write_atomic(output_path, lines)\n    print(f\"\\nüìÇ Estructura exportada a: {output_path}\")\n\n\nif __name__ == '__main__':\n    main()\n\n```",
  "tags": "[[‚öôÔ∏è Python]] [[-rep_export_LINUXandMAC_generate_structure.py]] [[--- Codigo]]",
  "type": "text/markdown",
  "created": "20250620153254437",
  "modified": "20250620153254437"
}