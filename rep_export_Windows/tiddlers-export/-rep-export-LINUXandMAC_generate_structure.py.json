{
  "title": "-rep-export-LINUXandMAC_generate_structure.py",
  "text": "## [[Tags]]\n[[‚öôÔ∏è Python]] [[-rep-export-LINUXandMAC_generate_structure.py]] [[--- Codigo]]\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nScript: generate_structure.py\nPlataformas objetivo: Linux y macOS\n\nEste script genera un archivo `estructura.txt` que muestra el √°rbol completo\nfiltrado del repositorio usando solo caracteres ASCII y codificado en UTF-8.\nAdmite exclusiones sensibles y respetar .gitignore, as√≠ como ejecuci√≥n en \"dry-run\".\n\nUso:\n  python3 generate_structure.py [--root PATH] [--output PATH]\n                               [--honor-gitignore]\n                               [-e PATTERN ...] [--exclude-from FILE]\n                               [--dry-run] [-v]\n\nEjemplo:\n  python3 generate_structure.py --honor-gitignore -e node_modules -e '*.log' --dry-run\n\"\"\"\nimport os\nimport sys\nimport argparse\nimport logging\nimport tempfile\nfrom pathlib import Path\nimport fnmatch\n\n# Exclusiones por defecto\nIGNORED_DIRS = {\n    '.git', '.svn', '.hg', '.idea', '__pycache__', 'node_modules',\n    'dist', 'build', 'venv', '.mypy_cache'\n}\nIGNORED_FILES = {'.DS_Store'}\nIGNORED_EXT = {\n    '.pyc', '.class', '.o', '.exe', '.dll', '.so', '.dylib', '.pdb'\n}\n\n\ndef load_gitignore_patterns(repo_root: Path):\n    \"\"\"Carga patrones desde .gitignore\"\"\"\n    patterns = []\n    gitignore = repo_root / '.gitignore'\n    if gitignore.is_file():\n        for line in gitignore.read_text(encoding='utf-8').splitlines():\n            line = line.strip()\n            if not line or line.startswith('#'):\n                continue\n            patterns.append(line)\n    return patterns\n\n\ndef matches_pattern(path: Path, patterns, repo_root: Path):\n    rel = str(path.relative_to(repo_root))\n    return any(fnmatch.fnmatch(rel, pat) for pat in patterns)\n\n\ndef should_skip(path: Path, repo_root: Path, exclude_patterns, honor_gitignore, gitignore_patterns):\n    name = path.name\n    if name in IGNORED_DIRS or name in IGNORED_FILES:\n        return True\n    if path.suffix.lower() in IGNORED_EXT:\n        return True\n    # Ocultos (excepto .gitignore)\n    if name.startswith('.') and name != '.gitignore':\n        return True\n    # Patrones extra\n    if exclude_patterns and matches_pattern(path, exclude_patterns, repo_root):\n        return True\n    # Patrones de .gitignore\n    if honor_gitignore and gitignore_patterns and matches_pattern(path, gitignore_patterns, repo_root):\n        # Excepciones: siempre incluir .gitignore y estructura.txt\n        rel = str(path.relative_to(repo_root))\n        if rel in ('.gitignore', 'estructura.txt'):\n            return False\n        return True\n    return False\n\n\ndef ascii_tree(root: Path, repo_root: Path, prefix='', args=None, gitignore_patterns=None):\n    \"\"\"Construye lista de l√≠neas con √°rbol ASCII filtrado\"\"\"\n    lines = []\n    try:\n        entries = sorted(root.iterdir(), key=lambda p: p.name.lower())\n    except PermissionError:\n        logging.warning(f\"Permiso denegado: {root}\")\n        return lines\n\n    entries = [\n        e for e in entries\n        if not should_skip(e, repo_root, args.exclude, args.honor_gitignore, gitignore_patterns)\n    ]\n\n    for idx, entry in enumerate(entries):\n        connector = '‚îî‚îÄ‚îÄ ' if idx == len(entries) - 1 else '‚îú‚îÄ‚îÄ '\n        lines.append(f\"{prefix}{connector}{entry.name}\")\n        if entry.is_dir() and not entry.is_symlink():\n            extension = '    ' if idx == len(entries) - 1 else '‚îÇ   '\n            lines += ascii_tree(entry, repo_root, prefix + extension, args, gitignore_patterns)\n\n    return lines\n\n\ndef write_atomic(path: Path, lines):\n    \"\"\"Escribe de forma at√≥mica reemplazando el archivo destino.\"\"\"\n    # Crear temporal en la misma carpeta para evitar cross-device errors\n    tmp = tempfile.NamedTemporaryFile(\n        'w',\n        delete=False,\n        encoding='utf-8',\n        dir=path.parent\n    )\n    with tmp:\n        tmp.write('\\n'.join(lines))\n    tmp_path = Path(tmp.name)\n    tmp_path.replace(path)\n    logging.info(f\"Estructura escrita en {path}\")\n\n\ndef parse_args():\n    p = argparse.ArgumentParser(\n        description=\"Genera un √°rbol ASCII del proyecto con exclusiones de privacidad.\"\n    )\n    p.add_argument(\n        '--root', type=Path,\n        help=\"Ruta ra√≠z del proyecto (por defecto: repo root)\"\n    )\n    p.add_argument(\n        '--output', '-o', type=Path, default=Path('estructura.txt'),\n        help=\"Archivo de destino (por defecto: <root>/estructura.txt)\"\n    )\n    p.add_argument(\n        '--honor-gitignore', action='store_true',\n        help=\"Excluir patrones listados en .gitignore\"\n    )\n    p.add_argument(\n        '-e', '--exclude', action='append', default=[],\n        help=\"Patr√≥n glob adicional a excluir (repetible)\"\n    )\n    p.add_argument(\n        '--exclude-from', type=Path,\n        help=\"Archivo con patrones glob a excluir (uno por l√≠nea)\"\n    )\n    p.add_argument(\n        '--dry-run', action='store_true',\n        help=\"Imprime √°rbol sin escribir archivo\"\n    )\n    p.add_argument(\n        '-v', '--verbose', action='count', default=0,\n        help=\"Aumenta nivel de detalle en logs\"\n    )\n    return p.parse_args()\n\n\ndef main():\n    args = parse_args()\n    level = logging.WARNING - (10 * args.verbose)\n    logging.basicConfig(level=level, format='[%(levelname)s] %(message)s')\n\n    repo_root = args.root or Path(__file__).resolve().parents[1]\n    os.chdir(repo_root)\n\n    gitignore_patterns = (\n        load_gitignore_patterns(repo_root)\n        if args.honor_gitignore else []\n    )\n\n    if args.exclude_from and args.exclude_from.is_file():\n        extra = [\n            line.strip() for line in\n            args.exclude_from.read_text(encoding='utf-8').splitlines()\n            if line.strip() and not line.startswith('#')\n        ]\n        args.exclude.extend(extra)\n\n    logging.info(f\"Generando estructura desde {repo_root}\")\n    lines = ascii_tree(\n        repo_root, repo_root, prefix='',\n        args=args, gitignore_patterns=gitignore_patterns\n    )\n\n    if args.dry_run:\n        print('\\n'.join(lines))\n        logging.info(\"[dry-run] no se escribi√≥ archivo\")\n        return\n\n    output_path = args.output if args.output.is_absolute() else repo_root / args.output\n    write_atomic(output_path, lines)\n    print(f\"\\nüìÇ Estructura exportada a: {output_path}\")\n\n\nif __name__ == '__main__':\n    main()\n\n```",
  "tags": "[[‚öôÔ∏è Python]] [[-rep-export-LINUXandMAC_generate_structure.py]] [[--- Codigo]]",
  "type": "text/markdown",
  "created": "20250609134240602",
  "modified": "20250609134240602"
}