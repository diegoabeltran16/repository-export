{
  "title": "-rep-export-Windows_cli_utils.py",
  "text": "## [[Tags]]\n[[‚öôÔ∏è Python]] [[-rep-export-Windows_cli_utils.py]] [[--- Codigo]]\n\n```Python\n#!/usr/bin/env python3\n\"\"\"\nM√≥dulo: cli_utils.py\nUbicaci√≥n: rep-export-Windows/\n\nUtilidades comunes para scripts CLI:\n- `prompt_yes_no`  ‚Üí Preguntas s√≠/no con valor por defecto.\n- `run_cmd`        ‚Üí Ejecutar subprocesos con captura de stdout, stderr y c√≥digo.\n- `get_additional_args` ‚Üí Parsear argumentos libres del usuario.\n- `confirm_overwrite`   ‚Üí Confirmar sobreescritura de archivos existentes.\n- `safe_print`     ‚Üí Imprime mensajes evitando errores de codificaci√≥n (emojis).\n- `load_ignore_spec` ‚Üí Carga y compila patrones de `.gitignore`.\n- `is_ignored`     ‚Üí Verifica si una ruta debe ser ignorada seg√∫n `.gitignore`.\n\"\"\"\nimport subprocess\nimport sys\nfrom pathlib import Path\nfrom typing import List, Tuple, Optional\nfrom pathspec import PathSpec\n\n\ndef safe_print(message: str) -> None:\n    \"\"\"Imprime evitando errores de codificaci√≥n en consolas con encoding limitado.\"\"\"\n    try:\n        print(message)\n    except UnicodeEncodeError:\n        encoding = sys.stdout.encoding or 'utf-8'\n        filtered = message.encode(encoding, errors='ignore').decode(encoding)\n        print(filtered)\n\n\ndef prompt_yes_no(question: str, default: bool = False) -> bool:\n    \"\"\"Pregunta interactiva s√≠/no con valor por defecto.\"\"\"\n    default_str = 'S/n' if default else 's/N'\n    while True:\n        resp = input(f\"{question} [{default_str}]: \").strip().lower()\n        if not resp:\n            return default\n        if resp in ('s', 'si', 'y', 'yes'):\n            return True\n        if resp in ('n', 'no'):\n            return False\n        safe_print(\"‚ùó Respuesta inv√°lida. Usa 's' o 'n'.\")\n\n\ndef run_cmd(cmd: List[str], cwd: Optional[Path] = None) -> Tuple[int, str, str]:\n    \"\"\"\n    Ejecuta un comando externo y captura salida.\n\n    Returns:\n        exit_code: C√≥digo de salida del proceso\n        stdout:   Salida est√°ndar capturada\n        stderr:   Salida de error capturada\n    \"\"\"\n    safe_print(f\"\\n‚ñ∂Ô∏è Ejecutando: {' '.join(cmd)}\\n\")\n    proc = subprocess.Popen(cmd, cwd=cwd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\n    out, err = proc.communicate()\n    if out:\n        safe_print(out)\n    if proc.returncode != 0:\n        safe_print(f\"‚ùå Error (code {proc.returncode}) al ejecutar: {cmd[0]}\")\n        if err:\n            safe_print(f\"üìã stderr:\\n{err}\")\n    return proc.returncode, out, err\n\n\ndef get_additional_args(script_name: str) -> List[str]:\n    \"\"\"Solicita argumentos adicionales para un script (retorna lista).\"\"\"\n    extras = input(f\"Argumentos extra para {script_name} (separados por espacios), o Enter para ninguno: \").strip()\n    return extras.split() if extras else []\n\n\ndef confirm_overwrite(path: Path) -> bool:\n    \"\"\"Verifica si el usuario acepta sobrescribir el archivo si ya existe.\"\"\"\n    if path.exists():\n        return prompt_yes_no(f\"El archivo '{path.name}' ya existe. ¬øSobrescribir?\", default=False)\n    return True\n\n\ndef load_ignore_spec(repo_root: Path) -> PathSpec:\n    \"\"\"\n    Carga y compila los patrones de `.gitignore` desde el directorio ra√≠z.\n    Devuelve un PathSpec usable para match_file(path).\n    \"\"\"\n    gitignore_path = repo_root / \".gitignore\"\n    if not gitignore_path.exists():\n        return PathSpec.from_lines(\"gitwildmatch\", [])\n\n    lines = []\n    with gitignore_path.open(\"r\", encoding=\"utf-8\") as f:\n        for line in f:\n            ln = line.strip()\n            if not ln or ln.startswith('#'):\n                continue\n            lines.append(ln)\n    return PathSpec.from_lines(\"gitwildmatch\", lines)\n\n\ndef is_ignored(path: Path, repo_root: Path, ignore_spec: PathSpec) -> bool:\n    \"\"\"\n    Verifica si una ruta debe ser ignorada por `.gitignore`.\n    Path debe ser relativo o absoluto dentro de repo_root.\n    \"\"\"\n    rel = str(path.relative_to(repo_root))\n    return ignore_spec.match_file(rel)\n\n```",
  "tags": "[[‚öôÔ∏è Python]] [[-rep-export-Windows_cli_utils.py]] [[--- Codigo]]",
  "type": "text/markdown",
  "created": "20250619220233447",
  "modified": "20250619220233447"
}